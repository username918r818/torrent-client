package util_test

import (
	"testing"

	"github.com/username918r818/torrent-client/util"
)

func TestDecodeInt(t *testing.T) {
	data := []byte("i42e")
	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}
	if b.Int != 42 {
		t.Errorf("expected 42, got %d", b.Int)
	}
}

func TestDecodeNegativeInt(t *testing.T) {
	data := []byte("i-99e")
	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}
	if b.Int != -99 {
		t.Errorf("expected -99, got %d", b.Int)
	}
}

func TestDecodeStr(t *testing.T) {
	data := []byte("4:spam")
	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}
	if string(b.Str) != "spam" {
		t.Errorf("expected spam, got %s", b.Str)
	}
}

func TestDecodeLongStr(t *testing.T) {
	data := []byte("11:spameggspam")
	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}
	if string(b.Str) != "spameggspam" {
		t.Errorf("expected spam, got %s", b.Str)
	}
}

func TestDecodeList(t *testing.T) {
	data := []byte("l4:spami42ee")
	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}
	if len(b.List) != 2 {
		t.Errorf("expected list of 2 elements, got %d", len(b.List))
	}
	if string(b.List[0].Str) != "spam" || b.List[1].Int != 42 {
		t.Errorf("unexpected list content: %+v", b.List)
	}
}

func TestDecodeDict(t *testing.T) {
	data := []byte("d3:cow3:moo4:spam4:eggse")
	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}
	dict := *b.Dict
	if dict["cow"].Str == nil || string(dict["cow"].Str) != "moo" {
		t.Errorf("expected cow=moo, got %+v", dict["cow"])
	}
	if dict["spam"].Str == nil || string(dict["spam"].Str) != "eggs" {
		t.Errorf("expected spam=eggs, got %+v", dict["spam"])
	}
}

func TestDecodeEmpty(t *testing.T) {
	_, err := util.Decode([]byte(""))
	if err == nil {
		t.Errorf("expected error on empty input")
	}
}

func TestDecodeInvalid(t *testing.T) {
	_, err := util.Decode([]byte("x42e"))
	if err == nil {
		t.Errorf("expected error on invalid tag")
	}
}

// generated by ai, fixed by human
func TestDecodeComplexTorrent(t *testing.T) {
	data := []byte(
		"d4:infod6:lengthi12345e4:name11:example.txt12:piece lengthi16384e6:pieces21:abcdefghijklmnopqrstee" +
			"8:announce28:http://tracker.test/announce5:filesld6:lengthi67890e" +
			"4:pathl9:file1.txtd6:lengthi13579e4:pathl9:file2.txteeeeee",
	)

	b, err := util.Decode(data)
	if err != nil {
		t.Fatal(err)
	}

	top := *b.Dict

	info := top["info"]
	if info.Int != 0 || info.List != nil || info.Dict == nil {
		t.Errorf("expected info to be dict, got %+v", info)
	}
	infoDict := *info.Dict
	if infoDict["length"].Int != 12345 {
		t.Errorf("expected info.length=12345, got %d", infoDict["length"].Int)
	}
	if string(infoDict["name"].Str) != "example.txt" {
		t.Errorf("expected info.name=example.txt, got %s", string(infoDict["name"].Str))
	}
	if infoDict["piece length"].Int != 16384 {
		t.Errorf("expected info.piece length=16384, got %d", infoDict["piece length"].Int)
	}
	if string(infoDict["pieces"].Str) != "abcdefghijklmnopqrste" {
		t.Errorf("expected info.pieces=abcdefghijklmnopqrste, got %s", string(infoDict["pieces"].Str))
	}

	if string(top["announce"].Str) != "http://tracker.test/announce" {
		t.Errorf("expected announce URL, got %s", string(top["announce"].Str))
	}

	files := top["files"]
	if len(files.List) != 1 {
		t.Errorf("expected 1 file entry, got %d", len(files.List))
	}
	file1 := files.List[0]
	if file1.Dict == nil {
		t.Errorf("expected file1 to be dict, got %+v", file1)
	}
	file1Dict := *file1.Dict
	if file1Dict["length"].Int != 67890 {
		t.Errorf("expected file1.length=67890, got %d", file1Dict["length"].Int)
	}

	path := file1Dict["path"].List
	if len(path) != 2 {
		t.Errorf("expected path length 2, got %d", len(path))
	}
	if string(path[0].Str) != "file1.txt" {
		t.Errorf("expected path[0]=file1.txt, got %s", string(path[0].Str))
	}

	nested := path[1]
	if nested.Dict == nil {
		t.Errorf("expected nested dict in path[1], got %+v", nested)
	}
	nestedDict := *nested.Dict
	if nestedDict["length"].Int != 13579 {
		t.Errorf("expected nested length=13579, got %d", nestedDict["length"].Int)
	}
	nestedPath := nestedDict["path"].List
	if len(nestedPath) != 1 || string(nestedPath[0].Str) != "file2.txt" {
		t.Errorf("expected nested path=file2.txt, got %+v", nestedPath)
	}
}

func TestGetIndecesofInfo(t *testing.T) {
	data := []byte(
		"d8:announce19:http://tracker1.com4:infod12:piece " +
			"lengthi32768e6:pieces40:ABCDEFGHIJKLMNOPQRSTABCDEFGHIJKLMNOPQRST4:" +
			"name4:root5:filesld6:lengthi111e4:pathl9:fileA.txteed6:lengthi222e4:pathl9:fileB.txteeeee",
	)

	expectedBegin, expectedEnd := 39, 203

	begin, end, err := util.GetIndeces("info", data)

	if err != nil {
		t.Fatal(err)
	}

	if begin != expectedBegin {
		t.Errorf("begin = %v, expected %v", begin, expectedBegin)
	}

	if end != expectedEnd {
		t.Errorf("end = %v, expected %v", end, expectedEnd)
	}

}

func TestGetIndecesofName(t *testing.T) {
	data := []byte(
		"d4:infod6:lengthi12345e4:name11:example.txt12:piece lengthi16384e6:pieces21:abcdefghijklmnopqrstee" +
			"8:announce28:http://tracker.test/announce5:filesld6:lengthi67890e" +
			"4:pathl9:file1.txtd6:lengthi13579e4:pathl9:file2.txteeeeee",
	)

	expectedBegin, expectedEnd := 108, 139

	begin, end, err := util.GetIndeces("announce", data)

	if err != nil {
		t.Fatal(err)
	}

	if begin != expectedBegin {
		t.Errorf("begin = %v, expected %v", begin, expectedBegin)
	}

	if end != expectedEnd {
		t.Errorf("end = %v, expected %v", end, expectedEnd)
	}

}
